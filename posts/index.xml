<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Ivan Sanchez</title>
		<link>https://isanchez.net/posts/</link>
		<description>Recent content in Posts on Ivan Sanchez</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-gb</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Tue, 24 Sep 2019 00:00:00 +0000</lastBuildDate>
		<atom:link href="https://isanchez.net/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Deployments vs Releases</title>
			<link>https://isanchez.net/posts/2018-10-30-deployments-vs-releases/</link>
			<pubDate>Tue, 30 Oct 2018 21:00:00 +0100</pubDate>
			
			<guid>https://isanchez.net/posts/2018-10-30-deployments-vs-releases/</guid>
			<description>When a team is looking to move towards Continuous Delivery, it comes a time when it’s essential to differentiate deployment from release.
Traditionally, new versions of the software are built, tested, and made available to users in cycles that vary from once every few days to every few months. In that context, each new version will most likely contain some visible impact to the user, so the words release and deployment tend to be used interchangeably to express when a new version has reached users.</description>
			<content type="html"><![CDATA[<p>When a team is looking to move towards Continuous Delivery, it comes a time when it’s essential to differentiate
<em>deployment</em> from <em><em>release</em></em>.</p>

<p>Traditionally, new versions of the software are built, tested, and made available to users in cycles that vary from
once every few days to every few months. In that context, each new version will most likely contain some visible
impact to the user, so the words <em>release</em> and <em>deployment</em> tend to be used interchangeably to express when a new version
has reached users.</p>

<p>In recent years, however, many development teams have been focusing on reducing the lead time to <em>deploy</em> any given
change down to hours or even minutes. That has been made possible by increasing the focus on automating most of the
steps required to verify, assemble and install new versions, as well as increasing the focus on instrumenting and
monitoring the software so problems can be spotted and fixed quickly.</p>

<p>The ability to <em>deploy</em> new versions of the software more frequently means that often a new version of the software
doesn’t necessarily contain a visible impact to the user. Those new versions are still worth deploying though, as they
represent small, valuable increments, and having the latest version of the software being exercised by users earlier
will:</p>

<ul>
<li>Help the team learn how their changes behave in production, where it actually matters.</li>
<li>Make potential problems (and bugs, in general) easier spot to remediate.</li>
<li>Exercise the tools and procedures used to build and <em>deploy</em> each version.</li>
<li>Promote a culture of continuous improvement.</li>
</ul>

<p>Some examples of small, “invisible” increments that benefit from being deployed as soon as they are ready are security
patches, performance improvements, or internal changes to make things simpler to evolve or maintain.</p>

<p>Being able to <em>deploy</em> sooner also means the team can take advantage of feature flags to hide incomplete features from
users until they are ready. During that period, the team may have the ability to enable them for specific users
(internal or external) to evaluate how it behaves before it can reach a wider audience. The feature can then be
<em>released</em> with greater confidence and at the most appropriate time.</p>

<p>The splitting of deployment and <em>release</em> may represent a significant shift for those used to longer <em>release</em> cycles.
The longer the <em>release</em> cycle is, the more significant are the changes, and higher is the chance of things going wrong.
The natural response, in this case, is to be more reluctant to <em>deploy</em> new changes, especially when the new version
doesn’t contain something visible to users.</p>

<p>In reality, <em>deploying more frequently de-risks releasing changes to the users</em>. That, in addition to the ability to
better control when and how changes are made available, should make this approach very attractive to modern software
development teams.</p>
]]></content>
		</item>
		
		<item>
			<title>Learning a new codebase from its history beyond the code</title>
			<link>https://isanchez.net/posts/2018-08-20-learning-a-new-codebase-from-its-history-beyond-the-code/</link>
			<pubDate>Mon, 20 Aug 2018 21:00:00 +0100</pubDate>
			
			<guid>https://isanchez.net/posts/2018-08-20-learning-a-new-codebase-from-its-history-beyond-the-code/</guid>
			<description>One of the most challenging aspects of learning a new codebase is to understand how things got to be the way they are now. Rather than viewing the current code/documentation as the current representation of reality, I find useful to see them as the result of many internal and external influences over time.
As developers, we tend to see source control as the official history of a codebase. Unfortunately, just looking at the previous commits, no matter how well organised they are, is barely enough to understand the decisions that shaped the system.</description>
			<content type="html"><![CDATA[<p>One of the most challenging aspects of learning a new codebase is to understand how things got to be the way they are now. Rather than viewing the current code/documentation as the current representation of reality, I find useful to see them as the result of many internal and external influences over time.</p>

<p>As developers, we tend to see source control as the official history of a codebase. Unfortunately, just looking at the previous commits, no matter how well organised they are, is barely enough to understand the decisions that shaped the system.</p>

<p>A better source of this kind of information is <a href="http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions">Architecture Decision Records (ADRs)</a>. When available, those records provide a convenient way to learn about the context where technical decisions were made.</p>

<p>Recently, I’ve been noticing that looking at those is rarely enough. There are clues about the codebase that go undocumented, and the only source is the memory of existing team members. A critical deadline, a strategic mission that eventually changed, a piece of infrastructure that was not particularly reliable, a part of that team that got moved to another country, or an influential team member who left, are all precious information to paint a complete picture of a software project.</p>

<p>Drawing together a timeline a whiteboard with the help of existing team members is an excellent approach to surface some of this history. However, I wish that information was readily available at any given point.</p>

<p>Here are some of the things I wish people documented over time:</p>

<ul>
<li>What drove the creation of this project in the first place?</li>
<li>What was the context of the company at that time?</li>
<li>Who was in the initial team?</li>
<li>How has the team structure changed?</li>
<li>What kind of challenges has the team faced over time?</li>
<li>What external forces had an impact on the project (positive or negative)?</li>
<li>Who joined/left the team?</li>
<li>Who were advocates or champions of specific tools, techniques, and approaches adopted by the team?</li>
<li>What was the technical context of the original architecture?</li>
<li>Were there any notable pivots in priorities or goals?</li>
</ul>

<p>That kind of information exists for any project, and it should be easy to track it as it happens for future reference. And because it’s factual, it does not require to be kept up to date like an architectural diagram.</p>

<p>In the last few days, I’ve been talking to <a href="https://twitter.com/natpryce">Nat Pryce</a> about some of these ideas, and he came up with <a href="https://github.com/npryce/pottery">Pottery</a>, a tool similar to his <a href="https://github.com/npryce/adr-tools">adr-tools</a> but intended to “record things that happen in a project”, like an internal Twitter feed. I’m curious to see this kind of approach adopted in the wild and the impact it can have on teams as they evolve.</p>

<p>Ultimately, learning a new codebase from a project history perspective is helpful beyond the technical sphere: it helps us to connect and empathise with the rest of the team and all the challenges that they have faced so far.</p>
]]></content>
		</item>
		
	</channel>
</rss>
